[ { "title": "Solving Project Euler: Problem 3", "url": "/posts/solving-project-euler-problems-3/", "categories": "Project Euler", "tags": "Python, Math, Programming, Project Euler", "date": "2023-12-21 17:00:00 +0530", "snippet": "Even Fibonacci NumbersProject Euler PromptThe prime factors of $13195$ are $5, 7, 13$ and $29$.What is the largest prime factor of the number $600851475143$?SolutionFirst ApproachThe code is fairly...", "content": "Even Fibonacci NumbersProject Euler PromptThe prime factors of $13195$ are $5, 7, 13$ and $29$.What is the largest prime factor of the number $600851475143$?SolutionFirst ApproachThe code is fairly straightforward, I wrote a general method to find out the largest primeimport mathdef largest_prime(n): prime_factors = 0 while n % 2 == 0: prime_factors = 2 n /= 2 # n is odd at this point for i in range(3, int(math.sqrt(n)+ 1), 2): while n % i == 0: if i &gt; prime_factors: prime_factors = i n /= i if n &gt; prime_factors: prime_factors = n print(prime_factors)How does this code workThere are three main steps we are using here Step 1 is to take care of numbers that are even, we repeatedly divide the number by 2 until the number becomes odd. Step 2 is to take care of the odd numbers, we start the range from 3 and increment the numbers by 2 here because 2 is the only even prime factor. Now, the reason why we have used $\\sqrt n + 1$ here is because of a simple property of composite numbers that every composite number has a prime factor either lesser or equal to it’s square root. So what we do is find the least prime factor, remove all occurences of it by dividing the number by the least prime factor and repeat it until the number reduces to either $1$ or a prime number whenever we encounter a prime number we check if it’s larger than the existing prime number and if it is we replace it." }, { "title": "Solving Project Euler: Problem 2", "url": "/posts/solving-project-euler-problems-2/", "categories": "Project Euler", "tags": "Python, Math, Programming, Project Euler", "date": "2022-01-30 17:18:00 +0530", "snippet": "Problem 2: Even Fibonacci NumbersHackerRank link: https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problemEach new term in the Fibonacci sequence is generated by adding the prev...", "content": "Problem 2: Even Fibonacci NumbersHackerRank link: https://www.hackerrank.com/contests/projecteuler/challenges/euler002/problemEach new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with $1$ and $2$, the first $10$ terms will be:\\[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\\]By considering the terms in the Fibonacci sequence whose values do not exceed $N$, find the sum of the even-valued terms.SolutionBrute Force ApproachThe solution for this is fairly straight forward. Generate fibonacci numbers. While generating the fibonacci numbers for every even fibonacci number we encounter we store it in a variable and we add the next even number we encounter to that variable. We stop generating the fibonacci numbers when our present number generated exceeds $N$The code for it is as follows:n = int(input().strip())first = 0second = 1third = 1evenSum = 0while True: first, second = second, third third = first + second if third &gt; n: break if (third % 2 == 0): res+=thirdprint(evenSum)While this works, there’s a more clever way to approach this problem mathematically by optimizing our Brute Force method.Optimized Brute Force ApproachWhat we’re tasked with is to find the sum of even valued terms. Let’s look at the Fibonacci sequence again starting from 1 and 1:\\[1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...\\]If we carefully observe the sequence we can see that every third term in the fibonacci sequence is even. So if we devise a way to calculate every third term in the sequence then we can optimize our brute force to reduce the number of steps required to calculate the sum.To do this we have to find a way to express our fibonacci sequence $F_n$ in terms of $F_{n-3}$ and $F_{n-6}$, this way we’re dealing with only even numbers.We start with the general equation of fibonacci series:\\[F_n = F_{n-1} + F_{n-2}\\]and then we expand on from that as follows\\[\\begin{align}F_n &amp;= F_{n-1} + F_{n-2}\\\\&amp;= F_{n-2} + F_{n-3} + F_{n-3} + F_{n-4} &amp; (F_{n-1} = F_{n-2} + F_{n-3})\\\\&amp;= F_{n-3} + F_{n-4} + F_{n-3} + F_{n-3} + F_{n-4}\\\\&amp;= 3F_{n-3} + 2F_{n-4}\\\\&amp;= 3F_{n-3} + F_{n-4} + F_{n-5} + F_{n-6}\\\\&amp;= 3F_{n-3} + F_{n-3} + F_{n-6} &amp; (F_{n-3} = F_{n-4} + F_{n-5})\\\\&amp;= 4F_{n-3} + F_{n-6}\\end{align}\\]We finally arrive at the equation\\[F_{n} = 4F_{n-3} + F_{n-6}\\]We can now code it out!n = int(input().strip())first_term = 2second_term = 0f_n = 2evenSum = 0while evenSum &lt; n: evenSum += f_n f_n = 4*first_term + second_term second_term, first_term = first_term, f_n print(evenSum)There are a few things to note here: We are starting the calculation from the 6th term in the fibonacci sequence, therefore the variable initialization is a bit different. The first_term variable corresponds to the first term in the equation we derived, therefore when calculating $F_6$, the first term will be $F_{6-3} = F_3$ and $F_3 = 2$ The second_term variable corresponds to the second term in the equation we derived, therefore when calculating $F_6$, the second term will be $F_{6-6} = F_0$ and $F_0 = 0$ Since we’re calculating only the even numbers in the sequence and summing it up, unlike the first brute force method we don’t have to check whether the sum is even because by definition it will always be even.Other than the points listed above, this code is straightforward and simple. This is still brute forcing but we’ve optimized it quite a bit." }, { "title": "Solving Project Euler: Problem 1", "url": "/posts/solving-project-euler-problems-1-5/", "categories": "Project Euler", "tags": "Programming, Math, Python, Project Euler", "date": "2022-01-30 13:39:00 +0530", "snippet": "Why Project Euler?I’ve always liked Math and Programming as a kid, there’s a satisfying feeling I get when I successfully solve a problem and that’s one of the reasons I choose to study engineering...", "content": "Why Project Euler?I’ve always liked Math and Programming as a kid, there’s a satisfying feeling I get when I successfully solve a problem and that’s one of the reasons I choose to study engineering. Even though I like Math and Programming I’ve never been really that good at it so I thought that Project Euler would help me hone my skills in both Math and Programming. The computational problems of Project Euler vary in difficulty but they’re very interesting with many having different ways to solve it.I thought I’d document my journey through solving these problems so here we are! There are a few things to note before we begin: I use HackerRank as my platform to solve these problems, HackerRank has the first 250 problems of Project Euler as a challenge on their website. I like the HackerRank platform so I’ll be using this. The programming language that I’ll be using is Python because that’s the language I’m currently focusing on.Problem 1: Multiples of 3 and 5HackerRank Link: https://www.hackerrank.com/contests/projecteuler/challenges/euler001/problemIf we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.Find the sum of all the multiples of 3 or 5 below N.My SolutionBrute Force ApproachThis is a fairly simple problem at first glance. You can brute force your way through it by iterating through all the numbers till N and check whether it’s a multiple of 3 or 5.The code for that would be like this:import syst = int(input().strip())for a0 in range(t): n = int(input().strip()) sum = 0 for i in range(n): if i % 3 == 0 or i % 5 == 0: sum+=i print(sum)Now this will work for small values of N like a 1000 or 10000, but for the constraints of the problem in HackerRank where N can $10^9$ this approach is too slow. The time complexity of the brute force method is $O(n)$ which is not too slow but there’s another Mathematical approach with a time complexity of $O(1)$ which is basically instantaneous.Mathematical ApproachOur main aim here is to find the sum of all multiples of $3$ or $5$ between $1$ and $N$. To approach this problem we can use the concept of Triangular Numbers. You can read about Triangular Numbers here, but what we need is the formula for the sum of N Natural Numbers and that is\\[T_{n} = \\sum_{k=1}^{N}k=1+2+3+…+N=\\frac{N(N+1)}{2}\\]With this we can proceed further. Let’s first consider multiples of 3, the sum of multiples of $3$ is\\[3+6+9+12+15+...+n_3\\]where $n_3 = 3*(N/3)$If we take $3$ as common from the equation than we get\\[3*(1+2+3+4+5+..+(N/3))\\]using the formula for the sum of $N$ natural numbers, the above equation can be simplified as\\[3* \\frac{N/3(N/3+1)}{2}\\]When we do the same thing for multiples of $5$ we get\\[5*\\frac{N/5(N/5+1)}{2}\\]so the equation for sum of multiples of $3$ or $5$ should be the sum of the above two equations that is\\[3*\\frac{N/3(N/3+1)}{2} + 5*\\frac{N/5(N/5+1)}{2}\\]but using this equation wouldn’t give you the right answer.You see, multiples of 3 and multiples of 5 have common multiples. They are $15, 30, 45, 60, 90 …$, there’s a pattern here and it is that all the common multiples of $3$ and $5$ are multiples of $15$. These multiples get added up twice, once in the sum of all multiples of $3$ equation and once in the sum of all multiples of $5$ equation. So we need to subtract it from the equation, hence we find the sum of all multiples of $15$ and subtract this sum from the above equation. Therefore our final equation would be\\[3*\\frac{N/3(N/3+1)}{2} + 5*\\frac{N/5(N/5+1)}{2} - 15*\\frac{N/15(N/15+1)}{2}\\]Coding this is simple, for the division in python you need to be a bit careful and use integer division (// operator) as the normal division returns a float and we don’t need decimal numbers here.def sum(n , k): d = n // k return (k * d * (d+1)) // 2import syst = int(input().strip())for a0 in range(t): n = int(input().strip()) print(sum(n - 1,3) + sum(n - 1, 5) - sum(n - 1,15))This is the final code, works like a charm and is in constant time $O(1)$ instead of linear time $O(n)$. This can handle cases of astronomically large numbers like $10^{30}$." } ]
